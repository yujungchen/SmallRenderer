
/*
	m_ColorImg = (unsigned char*)malloc(m_Width * m_Height * 3 * sizeof(unsigned char));
	glm::vec3 *Img;
	Img = (glm::vec3 *)malloc(m_Width * m_Height * sizeof(glm::vec3));
	for(int idx = 0 ; idx < m_Width * m_Height ; idx++){
		Img[idx] = glm::vec3(0.0, 0.0, 0.0);
		m_ColorImg[idx * 3] = 0;
		m_ColorImg[idx * 3 + 1] = 0;
		m_ColorImg[idx * 3 + 2] = 0;
	}



	Point hitP(0.0, 0.0, 0.0);
	int TotalSample = 16;
	
	srand (time(NULL));
	for(int SampleNum = 0 ; SampleNum < TotalSample ; SampleNum++){
		for(int h = m_Height - 1; h >= 0 ; h--){
			for(int w = 0; w < m_Width ; w++){
				glm::vec3 Dir(0.0, 0.0, 0.0);
				
				Dir.x = -1.0f + (RandomNumber() + w) * m_PxlSize_W;
				Dir.y = -1.0f + (RandomNumber() + h) * m_PxlSize_H;
				//printf("%f %f\n", RandomNumber(), RandomNumber());

				Dir = Dir.x * U + Dir.y * V + W;
				Dir = glm::normalize(Dir);

				Point EyeP(EyePos.x, EyePos.y, EyePos.z);
				Vector DirVec(Dir.x, Dir.y, Dir.z);
				Ray EyeRay(EyeP, DirVec, EPSILON);

				
				if(m_bvh->Intersect(EyeRay, insect)){
					float t = insect->uvt[2];
					hitP = EyeRay.o + t * EyeRay.d;
				}
				else
					continue;
				

				Normal n;
				Normal n0(model->normals[model->triangles[insect->triId].nindices[0] * 3 + 0], model->normals[model->triangles[insect->triId].nindices[0] * 3 + 1], model->normals[model->triangles[insect->triId].nindices[0] * 3 + 2]);
				Normal n1(model->normals[model->triangles[insect->triId].nindices[1] * 3 + 0], model->normals[model->triangles[insect->triId].nindices[1] * 3 + 1], model->normals[model->triangles[insect->triId].nindices[1] * 3 + 2]);
				Normal n2(model->normals[model->triangles[insect->triId].nindices[2] * 3 + 0], model->normals[model->triangles[insect->triId].nindices[2] * 3 + 1], model->normals[model->triangles[insect->triId].nindices[2] * 3 + 2]);
				n = BaryInterpolationN(n0, n1, n2, insect->uvt[0], insect->uvt[1]);
				
				Vector Kd, Ks;
				float Ns;
				
				m_PrimList[insect->triId].GetKdKsNs(insect->uvt[0], insect->uvt[1], Kd, Ks, Ns);

				int CurrentPxlIdx = h * m_Width + w;
				Img[CurrentPxlIdx].x = Img[CurrentPxlIdx].x + Kd.x;
				Img[CurrentPxlIdx].y = Img[CurrentPxlIdx].y + Kd.y;
				Img[CurrentPxlIdx].z = Img[CurrentPxlIdx].z + Kd.z;


			}
		}
	}

	FILE *OutImg_f;
	OutImg_f = fopen("Temp.raw", "wb");
	
	printf("%d x %d\n", m_Width, m_Height);

	for(int h = m_Height - 1; h >= 0 ; h--){
		for(int w = 0; w < m_Width ; w++){
			unsigned char r, g, b;
			int CurrentPxlIdx = h * m_Width + w;
			r = (unsigned char)(int)(Img[CurrentPxlIdx].x / (float)TotalSample * 255.0f);
			g = (unsigned char)(int)(Img[CurrentPxlIdx].y / (float)TotalSample * 255.0f);
			b = (unsigned char)(int)(Img[CurrentPxlIdx].z / (float)TotalSample * 255.0f);
			m_ColorImg[CurrentPxlIdx * 3] = r;
			m_ColorImg[CurrentPxlIdx * 3 + 1] = g;
			m_ColorImg[CurrentPxlIdx * 3 + 2] = b;
			fputc(r, OutImg_f);
			fputc(g, OutImg_f);
			fputc(b, OutImg_f);
		}
	}

	fclose(OutImg_f);

	frameToPPM("pTraceGolden.ppm", m_ColorImg, m_Width, m_Height);
	printf("Output Reference Done...\n\n");
*/	
